#!/usr/bin/env python3
from __future__ import annotations

import argparse
import json
import subprocess
import sys
from pathlib import Path
from typing import Any


ROOT = Path(__file__).resolve().parents[1]
EXECUTION_PLAN_PATH = ROOT / "docs" / "repo_improvements_execution_plan_v1.json"
STATUS_JSON_PATH = ROOT / "docs" / "repo_improvements_status.json"
STATUS_MD_PATH = ROOT / "docs" / "repo_improvements_status.md"


def _run(cmd: list[str]) -> int:
    return int(subprocess.call(cmd, cwd=ROOT))


def _read_json(path: Path) -> dict[str, Any]:
    return json.loads(path.read_text(encoding="utf-8"))


def _write_json(path: Path, payload: dict[str, Any]) -> None:
    path.write_text(json.dumps(payload, indent=2, sort_keys=True) + "\n", encoding="utf-8")


def build_status_payload(execution_plan: dict[str, Any]) -> dict[str, Any]:
    items = execution_plan.get("items") or []
    status_items: list[dict[str, Any]] = []
    for row in items:
        if not isinstance(row, dict):
            continue
        cid = str(row.get("canonical_item_id") or "")
        wave = str(row.get("wave") or "")
        classification = str(row.get("classification") or "")
        initial_status = "deferred" if classification == "deferred" else "todo"
        status_items.append(
            {
                "canonical_item_id": cid,
                "wave": wave,
                "status": initial_status,
                "owner": None,
                "linked_pr": None,
                "classification": classification,
                "priority_score": float(row.get("priority_score", 0.0)),
                "traceability": {
                    "target_paths": sorted(
                        [str(x) for x in (row.get("target_paths") or []) if isinstance(x, str)]
                    ),
                    "report_keys": ["report_keys"],
                },
                "validation": {
                    "tests": [],
                    "last_verified_utc": None,
                    "result": "pending",
                },
            }
        )
    status_items.sort(key=lambda x: str(x.get("canonical_item_id") or ""))
    return {
        "generated_by": "scripts/run_repo_improvements_pipeline.py",
        "source_execution_plan": "docs/repo_improvements_execution_plan_v1.json",
        "total_items": len(status_items),
        "items": status_items,
    }


def build_status_markdown(status_payload: dict[str, Any]) -> str:
    items = status_payload.get("items") or []
    lines: list[str] = []
    lines.append("# Repo Improvements Status")
    lines.append("")
    lines.append("Generated by `scripts/run_repo_improvements_pipeline.py`.")
    lines.append("")
    lines.append(f"- Total items: {status_payload.get('total_items')}")
    lines.append("")
    lines.append("| Canonical Item | Wave | Status | Classification | Priority |")
    lines.append("|---|---|---|---|---:|")
    for row in items:
        lines.append(
            "| "
            + " | ".join(
                [
                    f"`{row.get('canonical_item_id')}`",
                    str(row.get("wave")),
                    str(row.get("status")),
                    str(row.get("classification")),
                    f"{float(row.get('priority_score', 0.0)):.4f}",
                ]
            )
            + " |"
        )
    lines.append("")
    return "\n".join(lines).rstrip() + "\n"


def _write_or_verify_status(*, verify: bool) -> int:
    execution_plan = _read_json(EXECUTION_PLAN_PATH)
    status_payload = build_status_payload(execution_plan)
    status_md = build_status_markdown(status_payload)
    if verify:
        if not STATUS_JSON_PATH.exists() or not STATUS_MD_PATH.exists():
            return 2
        if _read_json(STATUS_JSON_PATH) != status_payload:
            return 2
        return 0 if STATUS_MD_PATH.read_text(encoding="utf-8") == status_md else 2
    STATUS_JSON_PATH.parent.mkdir(parents=True, exist_ok=True)
    _write_json(STATUS_JSON_PATH, status_payload)
    STATUS_MD_PATH.write_text(status_md, encoding="utf-8")
    return 0


def main() -> int:
    ap = argparse.ArgumentParser()
    ap.add_argument("--verify", action="store_true")
    args = ap.parse_args()

    verify = bool(args.verify)
    step_mode = ["--verify"] if verify else []
    steps = [
        ["scripts/canonicalize_repo_improvements_catalog.py"],
        ["scripts/normalize_repo_improvements_catalog.py"],
        ["scripts/map_repo_improvements_to_capabilities.py"],
        ["scripts/plan_repo_improvements_rollout.py"],
        ["scripts/validate_repo_improvement_dependencies.py"],
        ["scripts/scaffold_repo_improvement_plugins.py"],
        ["scripts/generate_codex_repo_manifest.py"],
        ["scripts/generate_codex_plugin_catalog.py"],
    ]
    for step in steps:
        cmd = [sys.executable, *step, *step_mode]
        rc = _run(cmd)
        if rc != 0:
            return rc

    rc = _write_or_verify_status(verify=verify)
    if rc != 0:
        return rc

    extra_steps = [
        ["scripts/full_instruction_coverage_report.py"],
        ["scripts/full_repo_misses.py"],
    ]
    for step in extra_steps:
        cmd = [sys.executable, *step, *step_mode]
        rc = _run(cmd)
        if rc != 0:
            return rc

    return 0


if __name__ == "__main__":
    raise SystemExit(main())
